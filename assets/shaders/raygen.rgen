/*
* File: raygen.rgen
* Project: blok
* Author: Collin Longoria
* Created on: 12/1/2025
* Updated: Refactored for new payload and RNG
*/

#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 3, set = 0) uniform FrameUBO {
    // Current frame
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;

    // Previous frame
    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;

    vec3 camPos;
    float deltaTime;

    vec3 prevCamPos;
    uint depth;

    uint frameCount;
    uint sampleCount;
    uint screenWidth;
    uint screenHeight;

    float temporalAlpha;
    float momentAlpha;
    float varianceClipGamma;
    float depthThreshold;

    float normalThreshold;
    float phiColor;
    float phiNormal;
    float phiDepth;

    int atrousIteration;
    int stepSize;
    float varianceBoost;
    int minHistoryLength;

    vec2 jitterOffset;
    vec2 _padding;
} frame;

layout(binding = 4, set = 0, rgba32f) uniform image2D outColor;
layout(binding = 5, set = 0, rgba32f) uniform image2D outWorldPosition;
layout(binding = 6, set = 0, rgba16f) uniform image2D outNormalRoughness;
layout(binding = 7, set = 0, rgba8)   uniform image2D outAlbedoMetallic;
layout(binding = 8, set = 0, rg16f)   uniform image2D outMotionVectors;

// Ray payload for path tracing
struct RayPayload {
    vec3 radiance;   // Emission
    vec3 throughput; // Explicit throughput not strictly needed in payload if handled in rgen, but keeping struct
    vec3 normal;
    vec3 albedo;
    float roughness;
    float metallic;
    float hitT;
};

layout(location = 0) rayPayloadEXT RayPayload payload;
layout(location = 1) rayPayloadEXT bool isShadowed;

const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;

// --- RNG Helpers ---

uint pcg(inout uint state) {
    uint oldState = state;
    state = oldState * 747796405u + 2891336453u;
    uint word = ((oldState >> ((oldState >> 28u) + 4u)) ^ oldState) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint state) {
    return float(pcg(state)) / 4294967295.0;
}

vec2 randomVec2(inout uint state) {
    return vec2(randomFloat(state), randomFloat(state));
}

uint initRNG(uvec2 pixel, uint frameIndex, uint sampleIndex) {
    uint seed = pixel.x + pixel.y * frame.screenWidth;
    seed ^= frameIndex * 747796405u;
    seed ^= sampleIndex * 1664525u;
    pcg(seed);
    pcg(seed);
    return seed;
}

// --- Sampling Helpers ---

vec3 sampleCosineHemisphere(vec2 u, vec3 N) {
    float r = sqrt(u.x);
    float phi = 2.0 * PI * u.y;
    float x = r * cos(phi);
    float y = r * sin(phi);
    float z = sqrt(max(0.0, 1.0 - u.x));

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * x + bitangent * y + N * z);
}

vec3 sampleGGX(vec2 u, vec3 N, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;

    float phi = 2.0 * PI * u.x;
    float cosTheta = sqrt((1.0 - u.y) / (1.0 + (a2 - 1.0) * u.y));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
}

vec3 getSkyColor(vec3 dir) {
    float t = 0.5 * (dir.y + 1.0);
    vec3 skyBottom = vec3(0.8, 0.85, 0.95);
    vec3 skyTop = vec3(0.4, 0.6, 0.9);
    vec3 skyColor = mix(skyBottom, skyTop, t);

    vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
    float sunDot = max(dot(dir, sunDir), 0.0);
    vec3 sunColor = vec3(1.0, 0.95, 0.8) * pow(sunDot, 128.0) * 5.0;
    vec3 sunGlow = vec3(1.0, 0.9, 0.7) * pow(sunDot, 8.0) * 0.3;

    return skyColor + sunColor + sunGlow;
}

vec2 computeMotionVector(vec3 worldPos, vec2 currentUV) {
    vec4 prevClip = frame.prevViewProj * vec4(worldPos, 1.0);
    vec3 prevNDC = prevClip.xyz / prevClip.w;
    vec2 prevUV = prevNDC.xy * 0.5 + 0.5;
    return currentUV - prevUV;
}

// --- Main ---

void main() {
    const uvec2 pixelCoord = gl_LaunchIDEXT.xy;
    const vec2 pixelSize = vec2(gl_LaunchSizeEXT.xy);
    vec2 currentUV = (vec2(pixelCoord) + 0.5) / pixelSize;

    // G-buffer accumulation variables
    vec3 firstHitPos = vec3(0.0);
    vec3 firstHitNormal = vec3(0.0);
    vec3 firstHitAlbedo = vec3(0.0);
    float firstHitRoughness = 0.0;
    float firstHitMetallic = 0.0;
    float firstHitDepth = 0.0;
    bool hadFirstHit = false;

    vec3 accumulatedColor = vec3(0.0);

    for (uint sampleIdx = 0u; sampleIdx < frame.sampleCount; sampleIdx++) {
        // Initialize RNG per sample
        uint rng = initRNG(pixelCoord, frame.frameCount, sampleIdx);

        // Jitter pixel sampling
        vec2 pixelCenter;
        if(sampleIdx == 0){
            pixelCenter = vec2(pixelCoord) + vec2(0.5);
        } else {
            vec2 jitter = randomVec2(rng) - 0.5;
            pixelCenter = vec2(pixelCoord) + vec2(0.5) + jitter * 0.5;
        }

        vec2 uv = pixelCenter / pixelSize;
        vec2 d = uv * 2.0 - 1.0;

        vec4 target = frame.invProj * vec4(d.x, d.y, 1.0, 1.0);
        vec3 rayDir = normalize((frame.invView * vec4(normalize(target.xyz), 0.0)).xyz);
        vec3 rayOrigin = frame.camPos;

        vec3 radiance = vec3(0.0);
        vec3 throughput = vec3(1.0);

        for (uint bounce = 0u; bounce < 2u; bounce++) {
            // Reset payload before trace
            payload.radiance = vec3(0.0);
            payload.hitT = -1.0;

            traceRayEXT(
                topLevelAS,
                gl_RayFlagsOpaqueEXT,
                0xFF,
                0,
                0,
                0,
                rayOrigin,
                0.001,
                rayDir,
                10000.0,
                0                       // payload location = 0
            );

            // Check for miss
            if (payload.hitT < 0.0) {
                radiance += throughput * getSkyColor(rayDir);
                break;
            }

            // Calculate hit position (not in payload)
            vec3 hitPos = rayOrigin + rayDir * payload.hitT;

            // Extract surface properties from payload
            vec3 N = payload.normal;
            vec3 albedo = payload.albedo;
            float roughness = payload.roughness;
            float metallic = payload.metallic;

            // Store G-buffer data (first bounce, first sample only)
            if (bounce == 0u && sampleIdx == 0u && !hadFirstHit) {
                hadFirstHit = true;
                firstHitPos = hitPos;
                firstHitNormal = N;
                firstHitAlbedo = albedo;
                firstHitRoughness = roughness;
                firstHitMetallic = metallic;
                firstHitDepth = payload.hitT;
            }

            // Ensure normal faces ray
            if (dot(N, rayDir) > 0.0) {
                N = -N;
            }

            // Emissive contribution (from payload.radiance)
            if (length(payload.radiance) > 0.0) {
                radiance += throughput * payload.radiance;
            }

            // Direct Lighting / Shadows
            vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
            float NdotL = max(dot(N, sunDir), 0.0);

            if (NdotL > 0.0 && bounce == 0u) {
                isShadowed = true; // Assume shadowed
                vec3 shadowOrigin = hitPos + N * 0.001;

                traceRayEXT(
                    topLevelAS,
                    gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                    0xFF,
                    0,
                    0,
                    1,  // missIndex = 1 for shadow miss shader
                    shadowOrigin,
                    0.001,
                    sunDir,
                    1000.0,
                    1   // payload location = 1 (bool isShadowed)
                );

                if (!isShadowed) {
                    vec3 sunRadiance = vec3(3.0, 2.9, 2.7);
                    vec3 diffuseColor = albedo * (1.0 - metallic);
                    radiance += throughput * diffuseColor * sunRadiance * NdotL * INV_PI;
                }
            }

            // Russian Roulette
            if (bounce > 1u) {
                float p = max(max(throughput.r, throughput.g), throughput.b);
                p = min(p, 0.95);
                if (randomFloat(rng) > p) {
                    break;
                }
                throughput /= p;
            }

            // Sample next direction
            vec2 u = randomVec2(rng);

            // Fresnel
            vec3 F0 = mix(vec3(0.04), albedo, metallic);
            vec3 V = -rayDir;
            float NdotV = max(dot(N, V), 0.0);
            vec3 F = fresnelSchlick(NdotV, F0);

            float specularWeight = (F.r + F.g + F.b) / 3.0;
            specularWeight = mix(specularWeight, 1.0, metallic);

            if (randomFloat(rng) < specularWeight) {
                // Specular
                vec3 H = sampleGGX(u, N, max(roughness, 0.04));
                vec3 newDir = reflect(rayDir, H);

                if (dot(newDir, N) <= 0.0) break;

                float HdotV = max(dot(H, V), 0.0);
                vec3 Fh = fresnelSchlick(HdotV, F0);

                throughput *= Fh / max(specularWeight, 0.001);
                rayDir = newDir;
            } else {
                // Diffuse
                vec3 newDir = sampleCosineHemisphere(u, N);
                vec3 diffuseColor = albedo * (1.0 - metallic);
                throughput *= diffuseColor / max(1.0 - specularWeight, 0.001);
                rayDir = newDir;
            }

            // Throughput clamping
            float maxThroughput = max(max(throughput.r, throughput.g), throughput.b);
            if (maxThroughput > 10.0) {
                throughput *= 10.0 / maxThroughput;
            }

            // Update ray origin
            rayOrigin = hitPos + N * 0.002;
        }

        accumulatedColor += radiance;
    }

    // Average samples
    vec3 color = accumulatedColor / float(frame.sampleCount);

    // Firefly clamp
    color = clamp(color, vec3(0.0), vec3(100.0));

    // Store outputs
    imageStore(outColor, ivec2(pixelCoord), vec4(color, 1.0));

    // Fill sky depth if we never hit anything
    if (!hadFirstHit) {
        firstHitDepth = 10000.0;
        firstHitPos = frame.camPos + normalize((frame.invView * vec4(0.0, 0.0, -1.0, 0.0)).xyz) * 10000.0;
    }

    imageStore(outWorldPosition, ivec2(pixelCoord), vec4(firstHitPos, firstHitDepth));
    imageStore(outNormalRoughness, ivec2(pixelCoord), vec4(firstHitNormal, firstHitRoughness));
    imageStore(outAlbedoMetallic, ivec2(pixelCoord), vec4(firstHitAlbedo, firstHitMetallic));

    vec2 motionVector = vec2(0.0);
    if (hadFirstHit && firstHitDepth < 9999.0) {
        motionVector = computeMotionVector(firstHitPos, currentUV);
    }
    imageStore(outMotionVectors, ivec2(pixelCoord), vec4(motionVector, 0.0, 0.0));
}