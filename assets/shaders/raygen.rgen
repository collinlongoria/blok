/*
* File: raygen.rgen
* Project: blok
* Author: Collin Longoria
* Created on: 12/1/2025
* Updated: Refactored for new payload and RNG
*/

#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 3, set = 0) uniform FrameUBO {
    // Current frame
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;

    // Previous frame
    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;

    vec3 camPos;
    float deltaTime;

    vec3 prevCamPos;
    uint depth;

    uint frameCount;
    uint sampleCount;
    uint screenWidth;
    uint screenHeight;

    float temporalAlpha;
    float momentAlpha;
    float varianceClipGamma;
    float depthThreshold;

    float normalThreshold;
    float phiColor;
    float phiNormal;
    float phiDepth;

    int atrousIteration;
    int stepSize;
    float varianceBoost;
    int minHistoryLength;

    vec2 jitterOffset;
    vec2 _padding;
} frame;

layout(binding = 4, set = 0, rgba32f) uniform image2D outColor;
layout(binding = 5, set = 0, rgba32f) uniform image2D outWorldPosition;
layout(binding = 6, set = 0, rgba16f) uniform image2D outNormalRoughness;
layout(binding = 7, set = 0, rgba8)   uniform image2D outAlbedoMetallic;
layout(binding = 8, set = 0, rg16f)   uniform image2D outMotionVectors;

// Ray payload for path tracing
struct RayPayload {
    vec3 radiance;   // Emission
    vec3 normal;
    vec3 albedo;
    float roughness;
    float metallic;
    float hitT;
};

layout(location = 0) rayPayloadEXT RayPayload payload;
layout(location = 1) rayPayloadEXT bool isShadowed;

const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;

uint pcg(inout uint state) {
    uint oldState = state;
    state = oldState * 747796405u + 2891336453u;
    uint word = ((oldState >> ((oldState >> 28u) + 4u)) ^ oldState) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint state) {
    return float(pcg(state)) / 4294967295.0;
}

vec2 randomVec2(inout uint state) {
    return vec2(randomFloat(state), randomFloat(state));
}

uint initRNG(uvec2 pixel, uint frameIndex, uint sampleIndex) {
    uint seed = pixel.x + pixel.y * frame.screenWidth;
    seed ^= frameIndex * 747796405u;
    seed ^= sampleIndex * 1664525u;
    pcg(seed);
    pcg(seed);
    return seed;
}

vec3 sampleCosineHemisphere(vec2 u, vec3 N) {
    float r = sqrt(u.x);
    float phi = 2.0 * PI * u.y;
    float x = r * cos(phi);
    float y = r * sin(phi);
    float z = sqrt(max(0.0, 1.0 - u.x));

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * x + bitangent * y + N * z);
}

vec3 sampleGGX(vec2 u, vec3 N, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;

    float phi = 2.0 * PI * u.x;
    float cosTheta = sqrt((1.0 - u.y) / (1.0 + (a2 - 1.0) * u.y));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
}

vec3 getSkyColor(vec3 dir) {
    float t = 0.5 * (dir.y + 1.0);
    vec3 skyBottom = vec3(0.8, 0.85, 0.95);
    vec3 skyTop = vec3(0.4, 0.6, 0.9);
    vec3 skyColor = mix(skyBottom, skyTop, t);

    vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
    float sunDot = max(dot(dir, sunDir), 0.0);
    vec3 sunColor = vec3(1.0, 0.95, 0.8) * pow(sunDot, 128.0) * 5.0;
    vec3 sunGlow = vec3(1.0, 0.9, 0.7) * pow(sunDot, 8.0) * 0.3;

    return skyColor + sunColor + sunGlow;
}

vec2 computeMotionVector(vec3 worldPos, vec2 currentUV) {
    vec4 prevClip = frame.prevViewProj * vec4(worldPos, 1.0);
    vec3 prevNDC = prevClip.xyz / prevClip.w;
    vec2 prevUV = prevNDC.xy * 0.5 + 0.5;
    return currentUV - prevUV;
}

// Check if a surface is primarily emissive (emission dominates over albedo)
bool isEmissive(vec3 emission) {
    return dot(emission, vec3(1.0)) > 0.01;
}

// Get luminance of a color
float luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
    const uvec2 pixelCoord = gl_LaunchIDEXT.xy;
    const vec2 pixelSize = vec2(gl_LaunchSizeEXT.xy);
    vec2 currentUV = (vec2(pixelCoord) + 0.5) / pixelSize;

    // G-buffer accumulation variables
    vec3 firstHitPos = vec3(0.0);
    vec3 firstHitNormal = vec3(0.0);
    vec3 firstHitAlbedo = vec3(0.0);
    vec3 firstHitEmission = vec3(0.0);
    float firstHitRoughness = 0.0;
    float firstHitMetallic = 0.0;
    float firstHitDepth = 0.0;
    bool hadFirstHit = false;
    bool firstHitWasEmissive = false;

    vec3 accumulatedColor = vec3(0.0);

    const vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
    const vec3 sunRadiance = vec3(3.0, 2.9, 2.7);

    for (uint sampleIdx = 0u; sampleIdx < frame.sampleCount; sampleIdx++) {
        // Initialize RNG per sample
        uint rng = initRNG(pixelCoord, frame.frameCount, sampleIdx);

        // Jitter pixel sampling
        vec2 pixelCenter;
        if(sampleIdx == 0u) {
            pixelCenter = vec2(pixelCoord) + vec2(0.5);
        } else {
            vec2 jitter = randomVec2(rng) - 0.5;
            pixelCenter = vec2(pixelCoord) + vec2(0.5) + jitter * 0.5;
        }

        vec2 uv = pixelCenter / pixelSize;
        vec2 d = uv * 2.0 - 1.0;

        vec4 target = frame.invProj * vec4(d.x, d.y, 1.0, 1.0);
        vec3 rayDir = normalize((frame.invView * vec4(normalize(target.xyz), 0.0)).xyz);
        vec3 rayOrigin = frame.camPos;

        vec3 radiance = vec3(0.0);
        vec3 throughput = vec3(1.0);

        const uint MAX_BOUNCES = 2u;
        for (uint bounce = 0u; bounce < MAX_BOUNCES; bounce++) {
            // Reset payload before trace
            payload.radiance = vec3(0.0);
            payload.hitT = -1.0;

            traceRayEXT(
                topLevelAS,
                gl_RayFlagsOpaqueEXT,
                0xFF,
                0,
                0,
                0,
                rayOrigin,
                0.001,
                rayDir,
                10000.0,
                0
            );

            // Check for miss
            if (payload.hitT < 0.0) {
                radiance += throughput * getSkyColor(rayDir);
                break;
            }

            // Calculate hit position (not in payload)
            vec3 hitPos = rayOrigin + rayDir * payload.hitT;

            // Extract surface properties from payload
            vec3 N = payload.normal;
            vec3 albedo = payload.albedo;
            vec3 emission = payload.radiance;
            float roughness = payload.roughness;
            float metallic = payload.metallic;

            // Ensure normal faces ray
            if (dot(N, rayDir) > 0.0) {
                N = -N;
            }

            // Store G-buffer data (first bounce, first sample only)
            if (bounce == 0u && sampleIdx == 0u && !hadFirstHit) {
                hadFirstHit = true;
                firstHitPos = hitPos;
                firstHitNormal = N;
                firstHitAlbedo = albedo;
                firstHitEmission = emission;
                firstHitRoughness = roughness;
                firstHitMetallic = metallic;
                firstHitDepth = payload.hitT;
                firstHitWasEmissive = isEmissive(emission);
            }

            if (isEmissive(emission)) {
                // Add emissive contribution
                radiance += throughput * emission;

                // For strongly emissive surfaces, we can optionally terminate
                // This prevents noise from bouncing off bright lights
                float emissionStrength = luminance(emission);
                if (emissionStrength > 5.0 || bounce > 0u) {
                    // Terminate path on bright emissives or secondary emissive hits
                    break;
                }
                // For dim emissives on first bounce, continue to also get reflected light
            }

            // Direct Lighting / Shadows
            float NdotL = max(dot(N, sunDir), 0.0);

            if (NdotL > 0.0 && bounce == 0u) {
                isShadowed = true; // Assume shadowed
                vec3 shadowOrigin = hitPos + N * 0.001;

                traceRayEXT(
                    topLevelAS,
                    gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                    0xFF,
                    0,
                    0,
                    1,  // missIndex = 1 for shadow miss shader
                    shadowOrigin,
                    0.001,
                    sunDir,
                    1000.0,
                    1   // payload location = 1 (bool isShadowed)
                );

                if (!isShadowed) {
                    // Diffuse contribution from sun
                    vec3 diffuseColor = albedo * (1.0 - metallic);
                    radiance += throughput * diffuseColor * sunRadiance * NdotL * INV_PI;

                    // Specular contribution from sun (for rough surfaces)
                    if (roughness < 0.9) {
                        vec3 H = normalize(sunDir - rayDir);
                        float NdotH = max(dot(N, H), 0.0);
                        float VdotH = max(dot(-rayDir, H), 0.0);

                        // Simplified GGX specular for direct light
                        float a = roughness * roughness;
                        float a2 = a * a;
                        float denom = NdotH * NdotH * (a2 - 1.0) + 1.0;
                        float D = a2 / (PI * denom * denom);

                        vec3 F0 = mix(vec3(0.04), albedo, metallic);
                        vec3 F = fresnelSchlick(VdotH, F0);

                        // Approximate visibility
                        float Vis = 0.25; // Simplified

                        radiance += throughput * F * D * Vis * sunRadiance * NdotL;
                    }
                }
            }

            // Russian Roulette
            if (bounce > 0u) {
                float p = min(max(max(throughput.r, throughput.g), throughput.b), 0.95);
                if (randomFloat(rng) > p) {
                    break;
                }
                throughput /= p;
            }

            // Sample next direction
            vec2 u = randomVec2(rng);

            // Fresnel
            vec3 F0 = mix(vec3(0.04), albedo, metallic);
            vec3 V = -rayDir;
            float NdotV = max(dot(N, V), 0.001);
            vec3 F = fresnelSchlick(NdotV, F0);

            float specularWeight = (F.r + F.g + F.b) / 3.0;
            specularWeight = mix(specularWeight, 1.0, metallic);

            if (randomFloat(rng) < specularWeight) {
                // Specular
                vec3 H = sampleGGX(u, N, max(roughness, 0.04));
                vec3 newDir = reflect(rayDir, H);

                if (dot(newDir, N) <= 0.0) break;

                float HdotV = max(dot(H, V), 0.0);
                vec3 Fh = fresnelSchlick(HdotV, F0);

                throughput *= Fh / max(specularWeight, 0.001);
                rayDir = newDir;
            } else {
                // Diffuse
                vec3 newDir = sampleCosineHemisphere(u, N);
                vec3 diffuseColor = albedo * (1.0 - metallic);
                throughput *= diffuseColor / max(1.0 - specularWeight, 0.001);
                rayDir = newDir;
            }

            // Throughput clamping
            float maxThroughput = max(max(throughput.r, throughput.g), throughput.b);
            if (maxThroughput > 10.0) {
                throughput *= 10.0 / maxThroughput;
            }

            // Update ray origin
            rayOrigin = hitPos + N * 0.002;
        }

        accumulatedColor += radiance;
    }

    // Average samples
    vec3 color = accumulatedColor / float(frame.sampleCount);

    // Firefly clamp
    float maxVal = max(max(color.r, color.g), color.b);
    if (maxVal > 100.0) {
        color *= 100.0 / maxVal;
    }

    // Store outputs
    imageStore(outColor, ivec2(pixelCoord), vec4(color, 1.0));

    // Fill sky depth if we never hit anything
    if (!hadFirstHit) {
        firstHitDepth = 10000.0;
        firstHitPos = frame.camPos + normalize((frame.invView * vec4(0.0, 0.0, -1.0, 0.0)).xyz) * 10000.0;
        firstHitNormal = vec3(0.0, 1.0, 0.0);
        firstHitAlbedo = getSkyColor(normalize(firstHitPos - frame.camPos));
    }

    // this helps the denoiser handle emissives
    vec3 finalAlbedo = firstHitWasEmissive ? firstHitEmission : firstHitAlbedo;

    imageStore(outWorldPosition, ivec2(pixelCoord), vec4(firstHitPos, firstHitDepth));
    imageStore(outNormalRoughness, ivec2(pixelCoord), vec4(firstHitNormal, firstHitRoughness));
    imageStore(outAlbedoMetallic, ivec2(pixelCoord), vec4(finalAlbedo, firstHitMetallic));

    vec2 motionVector = vec2(0.0);
    if (hadFirstHit && firstHitDepth < 9999.0) {
        motionVector = computeMotionVector(firstHitPos, currentUV);
    }
    imageStore(outMotionVectors, ivec2(pixelCoord), vec4(motionVector, 0.0, 0.0));
}