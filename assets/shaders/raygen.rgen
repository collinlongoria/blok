/*
* File: raygen.rgen
* Project: blok
* Author: Collin Longoria
* Created on: 12/1/2025
*/

#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 3, set = 0) uniform FrameUBO {
    // Current frame
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;

    // Previous frame
    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;

    vec3 camPos;
    float deltaTime;

    vec3 prevCamPos;
    uint depth;

    uint frameCount;
    uint sampleCount;
    uint screenWidth;
    uint screenHeight;

    float temporalAlpha;
    float momentAlpha;
    float varianceClipGamma;
    float depthThreshold;

    float normalThreshold;
    float phiColor;
    float phiNormal;
    float phiDepth;

    int atrousIteration;
    int stepSize;
    float varianceBoost;
    int minHistoryLength;

    vec2 jitterOffset;
    vec2 _padding;
} frame;
layout(binding = 4, set = 0, rgba32f) uniform image2D outColor;
layout(binding = 5, set = 0, rgba32f) uniform image2D outWorldPosition;
layout(binding = 6, set = 0, rgba16f) uniform image2D outNormalRoughness;
layout(binding = 7, set = 0, rgba8)   uniform image2D outAlbedoMetallic;
layout(binding = 8, set = 0, rg16f)   uniform image2D outMotionVectors;

// Ray payload for path tracing
struct RayPayload {
    vec3 color;         // Accumulated radiance
    vec3 throughput;    // Path throughput (for Russian Roulette)
    vec3 normal;        // Surface normal at hit
    vec3 hitPos;        // World position of hit
    vec3 albedo;        // Surface albedo
    float roughness;    // Surface roughness (for GGX)
    float metallic;     // Metallic factor
    float hitT;         // Hit distance (-1 if miss)
    uint rngState;      // Random state
};

layout(location = 0) rayPayloadEXT RayPayload payload;

const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;

// PRNG
// TODO move this to an include shader

uint pcg(inout uint state) {
    uint oldState = state;
    state = oldState * 747796405u + 2891336453u;
    uint word = ((oldState >> ((oldState >> 28u) + 4u)) ^ oldState) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint state) {
    return float(pcg(state)) / 4294967295.0;
}

vec2 randomVec2(inout uint state) {
    return vec2(randomFloat(state), randomFloat(state));
}

uint initRNG(uvec2 pixel, uint frame, uint sampleIndex) {
    uint seed = pixel.x + pixel.y * 65536u;
    seed ^= frame * 747796405u;
    seed ^= sampleIndex * 2891336453u;

    pcg(seed);
    pcg(seed);
    return seed;
}

// cosine-weighted hemisphere sampling (for diffuse)
vec3 sampleCosineHemisphere(vec2 u, vec3 N) {
    // map to disk
    float r = sqrt(u.x);
    float phi = 2.0 * PI * u.y;

    // map to hemisphere
    float x = r * cos(phi);
    float y = r * sin(phi);
    float z = sqrt(max(0.0, 1.0 - u.x));

    // create tangent space
    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * x + bitangent * y + N * z);
}

// GGX importance sampling for specular
vec3 sampleGGX(vec2 u, vec3 N, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;

    float phi = 2.0 * PI * u.x;
    float cosTheta = sqrt((1.0 - u.y) / (1.0 + (a2 - 1.0) * u.y));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    // spherical to cartesian (tangent space)
    vec3 H = vec3(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    );

    // create tangent space
    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    // transform to world space
    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

// Schlick Fresnel approximation
vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
}

vec3 getSkyColor(vec3 dir) {
    // sky
    float t = 0.5 * (dir.y + 1.0);
    vec3 skyBottom = vec3(0.8, 0.85, 0.95);
    vec3 skyTop = vec3(0.4, 0.6, 0.9);
    vec3 skyColor = mix(skyBottom, skyTop, t);

    // sun disk
    vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
    float sunDot = max(dot(dir, sunDir), 0.0);
    vec3 sunColor = vec3(1.0, 0.95, 0.8) * pow(sunDot, 128.0) * 5.0;

    // sun glow
    vec3 sunGlow = vec3(1.0, 0.9, 0.7) * pow(sunDot, 8.0) * 0.3;

    return skyColor + sunColor + sunGlow;
}

vec2 computeMotionVector(vec3 worldPos, vec2 currentUV) {
    // reproject to previous frame
    vec4 prevClip = frame.prevViewProj * vec4(worldPos, 1.0);
    vec3 prevNDC = prevClip.xyz / prevClip.w;
    vec2 prevUV = prevNDC.xy * 0.5 + 0.5;

    // motion vector is the diff between curr and prev screen position
    return currentUV - prevUV;
}

void main() {
    const uvec2 pixelCoord = gl_LaunchIDEXT.xy;
    const vec2 pixelSize = vec2(gl_LaunchSizeEXT.xy);
    vec2 currentUV = (vec2(pixelCoord) + 0.5) / pixelSize;

    // Initialize G-buffer outputs for this pixel
    vec3 firstHitPos = vec3(0.0);
    vec3 firstHitNormal = vec3(0.0, 1.0, 0.0);
    vec3 firstHitAlbedo = vec3(0.0);
    float firstHitRoughness = 1.0;
    float firstHitMetallic = 0.0;
    float firstHitDepth = -1.0;  // -1 means sky/miss
    bool hadFirstHit = false;

    // accumulate multiple samples
    vec3 accumulatedColor = vec3(0.0);
    const uint samplesPerPixel = max(frame.sampleCount, 1u);

    for (uint sampleIdx = 0u; sampleIdx < samplesPerPixel; sampleIdx++) {
        // init random
        uint rng = initRNG(pixelCoord, frame.frameCount, sampleIdx);

        // jitter pixel sampling for anti-aliasing
        vec2 pixelCenter;
        if(sampleIdx == 0){
            // Primary sample: use pixel center
            pixelCenter = vec2(pixelCoord) + vec2(0.5) + frame.jitterOffset;
        }
        else{
            // additional samples: add random jitter
            // AA handled in proj matrix
            vec2 jitter = randomVec2(rng) - 0.5;
            pixelCenter = vec2(pixelCoord) + vec2(0.5) + jitter * 0.5;
        }

        vec2 uv = pixelCenter / pixelSize;
        vec2 d = uv * 2.0 - 1.0;

        vec4 target = frame.invProj * vec4(d.x, d.y, 1.0, 1.0);
        vec3 rayDir = normalize((frame.invView * vec4(normalize(target.xyz), 0.0)).xyz);
        vec3 rayOrigin = frame.camPos;

        // path tracing state
        vec3 radiance = vec3(0.0);
        vec3 throughput = vec3(1.0);

        for (uint bounce = 0u; bounce < 4u; bounce++) {
            // init payload
            payload.color = vec3(0.0);
            payload.throughput = throughput;
            payload.hitT = -1.0;
            payload.rngState = rng;
            payload.roughness = 0.5; // arbitrary defaults btw
            payload.metallic = 0.0;

            // call trace ray
            traceRayEXT(
                topLevelAS,             // acceleration structure
                gl_RayFlagsOpaqueEXT,   // rayFlags
                0xFF,                   // cullMask
                0,                      // sbtRecordOffset for the hitgroups
                0,                      // sbtRecordStride for the hitgroups
                0,                      // missIndex
                rayOrigin,              // ray origin
                0.001,                  // ray min range
                rayDir,                 // ray direction
                10000.0,                // ray max range
                0                       // payload (location = 0)
            );

            // update the rng state from the payload
            rng = payload.rngState;

            // check for miss
            if (payload.hitT < 0.0) {
                radiance += throughput * getSkyColor(rayDir);
                break;
            }

            // Store first hit data for G-buffer (only on first bounce, first sample)
            if (bounce == 0u && sampleIdx == 0u && !hadFirstHit) {
                hadFirstHit = true;
                firstHitPos = payload.hitPos;
                firstHitNormal = payload.normal;
                firstHitAlbedo = payload.albedo;
                firstHitRoughness = payload.roughness;
                firstHitMetallic = payload.metallic;

                // Compute linear depth (distance from camera)
                firstHitDepth = payload.hitT;
            }

            // hit, so get surface props
            vec3 hitPos = payload.hitPos;
            vec3 N = payload.normal;
            vec3 albedo = payload.albedo;
            float roughness = payload.roughness;
            float metallic = payload.metallic;

            // ensure normal faces ray
            if (dot(N, rayDir) > 0.0) {
                N = -N;
            }

            // direct lighting
            // TODO a list of lights that the shader can use
            vec3 sunDir = normalize(vec3(0.5, 0.8, 0.3));
            float NdotL = max(dot(N, sunDir), 0.0);

            // TODO shadows (this just does direct lighting for now)
            if (NdotL > 0.0) {
                // simple direct lighting contribution
                vec3 sunRadiance = vec3(3.0, 2.9, 2.7);

                vec3 diffuseColor = albedo * (1.0 - metallic);
                radiance += throughput * diffuseColor * sunRadiance * NdotL * INV_PI;
            }

            // russian roulette
            if (bounce > 1u) {
                float p = max(max(throughput.r, throughput.g), throughput.b);
                p = min(p, 0.95);
                if (randomFloat(rng) > p) {
                    break;
                }
                throughput /= p;
            }

            // sample next direction based on material
            vec2 u = randomVec2(rng);

            // fresnel-weighted material selection
            vec3 F0 = mix(vec3(0.04), albedo, metallic);
            vec3 V = -rayDir;
            float NdotV = max(dot(N, V), 0.0);
            vec3 F = fresnelSchlick(NdotV, F0);

            // probability of specular vs diffuse based on Fresnel
            float specularWeight = (F.r + F.g + F.b) / 3.0;
            specularWeight = mix(specularWeight, 1.0, metallic); // (metals are always specular)

            // simple material model (blends between diffuse and specular based on metallic)
            if (randomFloat(rng) < specularWeight) {
                // specular
                vec3 H = sampleGGX(u, N, max(roughness, 0.04));
                vec3 newDir = reflect(rayDir, H);

                if (dot(newDir, N) <= 0.0) {
                    break;  // invalid reflection
                }

                float HdotV = max(dot(H, V), 0.0);
                vec3 Fh = fresnelSchlick(HdotV, F0);

                // Simplified specular throughput
                throughput *= Fh / max(specularWeight, 0.001);
                rayDir = newDir;
            }
            else {
                // diffuse (cosine-weighted)
                vec3 newDir = sampleCosineHemisphere(u, N);
                vec3 diffuseColor = albedo * (1.0 - metallic);
                throughput *= diffuseColor / max(1.0 - specularWeight, 0.001);
                rayDir = newDir;
            }

            // prevent throughput from exploding
            float maxThroughput = max(max(throughput.r, throughput.g), throughput.b);
            if (maxThroughput > 10.0) {
                throughput *= 10.0 / maxThroughput;
            }

            // update ray origin (offset to avoid self-intersection)
            rayOrigin = hitPos + N * 0.002;
        }

        accumulatedColor += radiance;
    }

    // average samples
    vec3 color = accumulatedColor / float(samplesPerPixel);

    // clamp to prevent infinite propagation - this should fix black spots?
    color = clamp(color, vec3(0.0), vec3(100.0));

    // Raw noisy color
    imageStore(outColor, ivec2(pixelCoord), vec4(color, 1.0));

    // World position + linear depth
    // If we missed (hit sky), store a large depth value
    if (!hadFirstHit) {
        firstHitDepth = 10000.0;
        firstHitPos = frame.camPos + normalize((frame.invView * vec4(0.0, 0.0, -1.0, 0.0)).xyz) * 10000.0;
    }
    imageStore(outWorldPosition, ivec2(pixelCoord), vec4(firstHitPos, firstHitDepth));

    // Normal (encoded) + roughness
    // Normals are in [-1, 1], we store them directly in 16F
    imageStore(outNormalRoughness, ivec2(pixelCoord), vec4(firstHitNormal, firstHitRoughness));

    // Albedo + metallic
    // Pack into RGBA8 [0, 255]
    imageStore(outAlbedoMetallic, ivec2(pixelCoord), vec4(firstHitAlbedo, firstHitMetallic));

    // Motion vectors
    vec2 motionVector = vec2(0.0);
    if (hadFirstHit && firstHitDepth < 9999.0) {
        motionVector = computeMotionVector(firstHitPos, currentUV);
    }
    imageStore(outMotionVectors, ivec2(pixelCoord), vec4(motionVector, 0.0, 0.0));
}
