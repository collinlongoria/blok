/*
* File: variance.comp
* Project: blok
* Author: Collin Longoria
* Created on: 12/5/2025
*/

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba32f) uniform readonly image2D inColor;
layout(binding = 1, rg32f)   uniform readonly image2D inMoments;
layout(binding = 2, r16f)    uniform readonly image2D inHistoryLength;

layout(binding = 3, r32f) uniform writeonly image2D outVariance;

layout(binding = 4) uniform FrameUBO {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;
    vec3 camPos;
    float deltaTime;
    vec3 prevCamPos;
    uint depth;
    uint frameCount;
    uint sampleCount;
    uint screenWidth;
    uint screenHeight;
    float temporalAlpha;
    float momentAlpha;
    float varianceClipGamma;
    float depthThreshold;
    float normalThreshold;
    float phiColor;
    float phiNormal;
    float phiDepth;
    int atrousIteration;
    int stepSize;
    float varianceBoost;
    int minHistoryLength;
} frame;

// Additional input for edge-aware variance
layout(binding = 5, rgba32f) uniform readonly image2D inWorldPosition;
layout(binding = 6, rgba16f) uniform readonly image2D inNormalRoughness;

float luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// IMPROVED: Edge-aware spatial variance
float computeSpatialVariance(ivec2 coord, vec3 centerNormal, float centerDepth) {
    float m1 = 0.0;
    float m2 = 0.0;
    float totalWeight = 0.0;

    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            ivec2 sampleCoord = coord + ivec2(dx, dy);
            sampleCoord = clamp(sampleCoord, ivec2(0), ivec2(frame.screenWidth - 1, frame.screenHeight - 1));

            // Get sample geometry
            vec4 sampleWorldPos = imageLoad(inWorldPosition, sampleCoord);
            vec4 sampleNormalData = imageLoad(inNormalRoughness, sampleCoord);
            float sampleDepth = sampleWorldPos.w;
            vec3 sampleNormal = normalize(sampleNormalData.xyz);

            // Edge-aware weighting
            float depthDiff = abs(centerDepth - sampleDepth);
            float normalDot = dot(centerNormal, sampleNormal);

            // Only include samples on same surface
            float depthWeight = exp(-depthDiff * depthDiff / (0.5 * 0.5));
            float normalWeight = normalDot > 0.9 ? 1.0 : 0.0;
            float weight = depthWeight * normalWeight;

            if (weight > 0.01) {
                vec3 color = imageLoad(inColor, sampleCoord).rgb;
                float lum = luminance(color);

                m1 += lum * weight;
                m2 += lum * lum * weight;
                totalWeight += weight;
            }
        }
    }

    if (totalWeight > 0.0) {
        float mean = m1 / totalWeight;
        return max(m2 / totalWeight - mean * mean, 0.0);
    }

    return 0.0;
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    if (coord.x >= int(frame.screenWidth) || coord.y >= int(frame.screenHeight)) {
        return;
    }

    // Load temporal moments
    vec2 moments = imageLoad(inMoments, coord).rg;
    float historyLength = imageLoad(inHistoryLength, coord).r;

    // Load geometry for edge-aware filtering
    vec4 worldPosData = imageLoad(inWorldPosition, coord);
    vec4 normalData = imageLoad(inNormalRoughness, coord);
    float centerDepth = worldPosData.w;
    vec3 centerNormal = normalize(normalData.xyz);

    // Temporal variance from moments
    float temporalVariance = max(moments.y - moments.x * moments.x, 0.0);

    // Edge-aware spatial variance
    float spatialVariance = computeSpatialVariance(coord, centerNormal, centerDepth);

    // Blend based on history length
    // Need more samples before trusting temporal variance
    float minHistLen = float(max(frame.minHistoryLength, 4));
    float historyWeight = clamp((historyLength - 1.0) / minHistLen, 0.0, 1.0);

    // Smooth transition
    historyWeight = historyWeight * historyWeight; // Quadratic for smoother transition

    float variance = mix(spatialVariance, temporalVariance, historyWeight);

    // Boost variance for undersampled regions
    if (historyLength < minHistLen) {
        // Gradual boost instead of binary
        float boostFactor = mix(frame.varianceBoost, 1.0, historyLength / minHistLen);
        variance *= boostFactor;
    }

    // Minimum variance floor
    variance = max(variance, 0.0001);

    imageStore(outVariance, coord, vec4(variance, 0.0, 0.0, 0.0));
}