/*
* File: tonemap.comp
* Project: blok
* Author: Collin Longoria
* Created on: 12/8/2025
*/

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D hdrInput;
layout(binding = 1, rgba8) uniform image2D ldrOutput;

layout(push_constant) uniform PushConstants {
    float exposure;
    float saturationBoost;
    int tonemapOperator; // 0 = Neutral (functionally OFF), 1 = Khronos PBR Neutral
    float whitePoint;
} pc;

const float PI = 3.14159265359;

// color space stuff
float getLuminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// attempt to preserve chromaticity while changing luminance
vec3 changeLuminance(vec3 color, float newLuminance) {
    float oldLuminance = getLuminance(color);
    if (oldLuminance < 0.0001) return vec3(newLuminance);
    return color * (newLuminance / oldLuminance);
}

// saturation adjustment
vec3 adjustSaturation(vec3 color, float saturation) {
    float luma = getLuminance(color);
    return mix(vec3(luma), color, saturation);
}

// post-tonemap saturation recovery
vec3 postTonemapSaturationBoost(vec3 tonemapped, vec3 originalHdr, float boost) {
    if (boost <= 1.0) return tonemapped;

    // calculate saturation in HDR
    float hdrLuma = getLuminance(originalHdr);
    float hdrSat = (hdrLuma > 0.0001) ? length(originalHdr - vec3(hdrLuma)) / hdrLuma : 0.0;

    // calculate saturation in tonemapped
    float ldrLuma = getLuminance(tonemapped);
    float ldrSat = (ldrLuma > 0.0001) ? length(tonemapped - vec3(ldrLuma)) / ldrLuma : 0.0;

    // recover some lost saturation
    if (ldrSat > 0.0001 && ldrLuma > 0.01) {
        float satRatio = min(hdrSat / max(ldrSat, 0.001), 2.0);
        float recovery = mix(1.0, satRatio, (boost - 1.0));
        return mix(vec3(ldrLuma), tonemapped, min(recovery, 1.5));
    }
    return tonemapped;
}

// Khronos PBR Neutral tonemap
// https://github.com/KhronosGroup/ToneMapping
vec3 khronosPbrNeutral(vec3 hdr) {
    const float startCompression = 0.8 - 0.04;
    const float desaturation = 0.15;

    float x = min(hdr.r, min(hdr.g, hdr.b));
    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
    hdr -= offset;

    float peak = max(hdr.r, max(hdr.g, hdr.b));
    if (peak < startCompression) return hdr;

    float d = 1.0 - startCompression;
    float newPeak = 1.0 - d * d / (peak + d - startCompression);
    hdr *= newPeak / peak;

    float g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);
    return mix(hdr, vec3(newPeak), g);
}

// just soft clipping
vec3 neutralTonemap(vec3 hdr) {
    // Soft knee compression
    float peak = max(max(hdr.r, hdr.g), hdr.b);

    if (peak <= 1.0) return hdr;

    // Soft compression above 1.0
    float compressed = 1.0 - exp(-(peak - 1.0));
    float scale = (1.0 + compressed) / peak;

    return hdr * scale;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(ldrOutput);

    if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(outputSize);

    // Sample HDR input
    vec3 hdr = texture(hdrInput, uv).rgb;

    // Apply exposure
    hdr *= pc.exposure;

    // Store original for saturation recovery
    vec3 hdrOriginal = hdr;

    // apply tonemapping
    vec3 ldr;
    switch (pc.tonemapOperator) {
        case 0:  // Neutral (soft clip)
            ldr = neutralTonemap(hdr);
            break;
        case 1:  // Khronos PBR Neutral
            ldr = khronosPbrNeutral(hdr);
            break;
        default:
            ldr = khronosPbrNeutral(hdr);
            break;
    }

    // apply saturation boost if needed
    if (pc.saturationBoost > 1.0) {
        ldr = postTonemapSaturationBoost(ldr, hdrOriginal, pc.saturationBoost);
    } else if (pc.saturationBoost < 1.0 && pc.saturationBoost > 0.0) {
        // allow desaturation too
        float luma = getLuminance(ldr);
        ldr = mix(vec3(luma), ldr, pc.saturationBoost);
    }

    // clamp to valid range
    ldr = clamp(ldr, 0.0, 1.0);

    // write output
    imageStore(ldrOutput, pixelCoord, vec4(ldr, 1.0));
}