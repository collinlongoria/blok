/*
* File: intersect.rint
* Project: blok
* Author: Collin Longoria
* Created on: 12/1/2025
*/

#version 460
#extension GL_EXT_ray_tracing : require

struct SvoNode {
    uint childMask;
    uint firstChild;
    uint materialId;
    float occupancy;
};

struct ChunkGpu {
    uint nodeOffset;
    uint nodeCount;
    uint reserved0;
    uint reserved1;
    vec3 worldMin;
    float pad0;
    vec3 worldMax;
    float pad1;
};

layout(binding = 1, set = 0) readonly buffer SvoBuffer {
    SvoNode nodes[];
};

layout(binding = 2, set = 0) readonly buffer ChunkBuffer {
    ChunkGpu chunks[];
};

struct HitAttribs {
    vec3 normal;
    uint materialId;
};
hitAttributeEXT HitAttribs hitAttribs;

const uint INVALID_NODE_INDEX = 0xFFFFFFFF;
const uint MAX_DEPTH = 7u;
const uint MAX_STACK = 12u;

// precompute inverse direction with safer handling of near-zero components
const float INV_EPS = 1e-8;

const uint MAX_ITER = 128u; // was 256, trying lower for optimization purposes

// ray-AABB slab test with normal output that also outputs face
vec2 intersectAABB(vec3 rayOrigin, vec3 invDir, vec3 boxMin, vec3 boxMax, out int hitFace) {
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tNear = tmin.x;
    hitFace = 0; // -X or +X

    if (tmin.y > tNear) {
        tNear = tmin.y;
        hitFace = 1; // -Y or +Y
    }
    if (tmin.z > tNear) {
        tNear = tmin.z;
        hitFace = 2; // -Z or +Z
    }

    float tFar = min(min(tmax.x, tmax.y), tmax.z);

    return vec2(tNear, tFar);
}

// original version - still used for culling children
vec2 intersectAABBSimple(vec3 rayOrigin, vec3 invDir, vec3 boxMin, vec3 boxMax) {
    vec3 t0 = (boxMin - rayOrigin) * invDir;
    vec3 t1 = (boxMax - rayOrigin) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);

    return vec2(tNear, tFar);
}

// get the minimum corner of a child octant
vec3 getChildMin(vec3 parentMin, float childSize, uint octant) {
    return parentMin + vec3(
        (octant & 1u) != 0u ? childSize : 0.0,
        (octant & 2u) != 0u ? childSize : 0.0,
        (octant & 4u) != 0u ? childSize : 0.0
    );
}

// compute child traversal order mask based on ray direction
// XOR with child index gives front-to-back order
uint computeChildOrderMask(vec3 rayDir) {
    uint mask = 0u;
    if (rayDir.x < 0.0) mask |= 1u;
    if (rayDir.y < 0.0) mask |= 2u;
    if (rayDir.z < 0.0) mask |= 4u;
    return mask;
}

// compute face normal from hit point
vec3 computeNormal(int hitFace, vec3 rayDir) {
    vec3 normal;

    switch (hitFace) {
        case 0: // X face
            normal = vec3(rayDir.x > 0.0 ? -1.0 : 1.0, 0.0, 0.0);
            break;
        case 1: // Y face
            normal = vec3(0.0, rayDir.y > 0.0 ? -1.0 : 1.0, 0.0);
            break;
        case 2: // Z face
        default:
            normal = vec3(0.0, 0.0, rayDir.z > 0.0 ? -1.0 : 1.0);
            break;
    }

    return normal;
}

void main() {
    uint chunkIndex = gl_PrimitiveID;
    ChunkGpu chunk = chunks[chunkIndex];

    vec3 rayOrigin = gl_WorldRayOriginEXT;
    vec3 rayDir = gl_WorldRayDirectionEXT;

    // precompute inverse direction
    vec3 invDir = vec3(
        abs(rayDir.x) > INV_EPS ? 1.0 / rayDir.x : sign(rayDir.x) * 1e30,
        abs(rayDir.y) > INV_EPS ? 1.0 / rayDir.y : sign(rayDir.y) * 1e30,
        abs(rayDir.z) > INV_EPS ? 1.0 / rayDir.z : sign(rayDir.z) * 1e30
    );

    if (rayDir.x == 0.0) invDir.x = 1e30;
    if (rayDir.y == 0.0) invDir.y = 1e30;
    if (rayDir.z == 0.0) invDir.z = 1e30;

    // test chunk AABB
    int dummyFace;
    vec2 chunkT = intersectAABB(rayOrigin, invDir, chunk.worldMin, chunk.worldMax, dummyFace);
    float tNear = max(chunkT.x, gl_RayTminEXT);
    float tFar = min(chunkT.y, gl_RayTmaxEXT);

    if (tNear > tFar || tFar < 0.0) {
        return;
    }

    uint childOrderMask = computeChildOrderMask(rayDir);

    // stack arrays
    uint  sNodeIndex[MAX_STACK];
    uint  sDepth[MAX_STACK];
    vec3  sNodeMin[MAX_STACK];
    float sNodeSize[MAX_STACK];
    uint  sNextChild[MAX_STACK];

    // push root
    float chunkSize = chunk.worldMax.x - chunk.worldMin.x;
    sNodeIndex[0] = chunk.nodeOffset;
    sDepth[0] = 0u;
    sNodeMin[0] = chunk.worldMin;
    sNodeSize[0] = chunkSize;
    sNextChild[0] = 0u;
    uint stackPtr = 1u;

    float bestT = gl_RayTmaxEXT;
    bool foundHit = false;
    vec3 bestNormal;
    uint bestMaterialId;

    uint iter = 0u;

    while (stackPtr > 0u && iter < MAX_ITER) {
        iter++;

        uint si = stackPtr - 1u;

        // are all children processed?
        if (sNextChild[si] >= 8u) {
            stackPtr--;
            continue;
        }

        uint nodeIndex = sNodeIndex[si];
        uint depth = sDepth[si];
        vec3 nodeMin = sNodeMin[si];
        float nodeSize = sNodeSize[si];

        // bounds check
        if (nodeIndex >= chunk.nodeOffset + chunk.nodeCount) {
            stackPtr--;
            continue;
        }

        SvoNode node = nodes[nodeIndex];
        float childSize = nodeSize * 0.5;

        // early exit optimization. skip if no children
        if (node.childMask == 0u) {
            stackPtr--;
            continue;
        }

        // find next valid child
        bool foundChild = false;
        uint childNodeIndex;
        vec3 childMin;

        int childHitFace;

        while (sNextChild[si] < 8u) {
            uint c = sNextChild[si];
            sNextChild[si] = c + 1u;

            uint octant = c ^ childOrderMask;  // front to back order

            // does child exist?
            if ((node.childMask & (1u << octant)) == 0u) {
                continue;
            }

            // are children allocated?
            if (node.firstChild == INVALID_NODE_INDEX) {
                continue;
            }

            // compute child bounds
            childMin = getChildMin(nodeMin, childSize, octant);
            vec3 childMax = childMin + vec3(childSize);

            // ray-AABB test
            vec2 childT = intersectAABB(rayOrigin, invDir, childMin, childMax, childHitFace);
            float childTNear = max(childT.x, gl_RayTminEXT);
            float childTFar = min(childT.y, bestT);

            if (childTNear > childTFar || childTFar < 0.0) {
                continue;
            }

            childNodeIndex = chunk.nodeOffset + node.firstChild + octant;

            // bounds check
            if (childNodeIndex >= chunk.nodeOffset + chunk.nodeCount) {
                continue;
            }

            foundChild = true;
            break;
        }

        if (!foundChild) {
            stackPtr--;
            continue;
        }

        // is this a leaf level?
        if (depth + 1u >= MAX_DEPTH) {
            SvoNode leaf = nodes[childNodeIndex];

            if (leaf.occupancy > 0.0) {
                vec3 childMax = childMin + vec3(childSize);

                int leafHitFace;
                vec2 leafT = intersectAABB(rayOrigin, invDir, childMin, childMax, leafHitFace);
                float hitT = max(leafT.x, gl_RayTminEXT);

                if (hitT < bestT && hitT >= gl_RayTminEXT) {
                    bestT = hitT;
                    foundHit = true;
                    bestNormal = computeNormal(leafHitFace, rayDir);
                    bestMaterialId = leaf.materialId;
                }
            }
            continue;  // don't push leaves
        }

        // push child for traversal
        if (stackPtr < MAX_STACK) {
            sNodeIndex[stackPtr] = childNodeIndex;
            sDepth[stackPtr] = depth + 1u;
            sNodeMin[stackPtr] = childMin;
            sNodeSize[stackPtr] = childSize;
            sNextChild[stackPtr] = 0u;
            stackPtr++;
        }
    }

    if (foundHit) {
        hitAttribs.normal = bestNormal;
        hitAttribs.materialId = bestMaterialId;
        reportIntersectionEXT(bestT, 0);
    }
}
