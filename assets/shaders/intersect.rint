/*
* File: intersect.rint
* Project: blok
* Author: Collin Longoria
* Created on: 12/1/2025
*/

#version 460
#extension GL_EXT_ray_tracing : require

struct SvoNode {
    uint childMask;
    uint firstChild;
    uint materialId;
    float occupancy;
};

struct ChunkGpu {
    uint nodeOffset;
    uint nodeCount;
    uint reserved0;
    uint reserved1;
    vec3 worldMin;
    float pad0;
    vec3 worldMax;
    float pad1;
};

layout(binding = 1, set = 0) readonly buffer SvoBuffer {
    SvoNode nodes[];
};

layout(binding = 2, set = 0) readonly buffer ChunkBuffer {
    ChunkGpu chunks[];
};

struct HitAttribs {
    uint materialId;
};
hitAttributeEXT HitAttribs hitAttribs;

const uint MAX_STACK = 12u;
const uint MAX_ITER = 128u;
const uint MAX_DEPTH = 7u;
const float INV_EPS = 1e-8;

vec2 intersectAABB(vec3 origin, vec3 invDir, vec3 boxMin, vec3 boxMax) {
    vec3 t0 = (boxMin - origin) * invDir;
    vec3 t1 = (boxMax - origin) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);

    return vec2(tNear, tFar);
}

uint getHitFace(vec3 hitPos, vec3 boxMin, vec3 boxMax) {
    vec3 center = (boxMin + boxMax) * 0.5;
    vec3 diff = hitPos - center;
    vec3 halfSize = (boxMax - boxMin) * 0.5;
    vec3 dist = abs(diff) - halfSize;

    if (dist.x > dist.y && dist.x > dist.z) return diff.x > 0 ? 0 : 1;
    if (dist.y > dist.z) return diff.y > 0 ? 2 : 3;
    return diff.z > 0 ? 4 : 5;
}

void main() {
    ChunkGpu chunk = chunks[gl_PrimitiveID];
    vec3 rayOrg = gl_WorldRayOriginEXT;
    vec3 rayDir = gl_WorldRayDirectionEXT;

    vec3 invDir = vec3(
        abs(rayDir.x) > INV_EPS ? 1.0 / rayDir.x : sign(rayDir.x) * 1e30,
        abs(rayDir.y) > INV_EPS ? 1.0 / rayDir.y : sign(rayDir.y) * 1e30,
        abs(rayDir.z) > INV_EPS ? 1.0 / rayDir.z : sign(rayDir.z) * 1e30
    );

    vec2 chunkT = intersectAABB(rayOrg, invDir, chunk.worldMin, chunk.worldMax);
    if (chunkT.x > chunkT.y || chunkT.y < 0.0 || chunkT.x > gl_RayTmaxEXT) return;

    // Stack with depth tracking
    uint sNode[MAX_STACK];
    vec3 sMin[MAX_STACK];
    float sSize[MAX_STACK];
    uint sDepth[MAX_STACK];
    uint sNextChild[MAX_STACK];

    uint orderMask = 0u;
    if (rayDir.x < 0.0) orderMask |= 1u;
    if (rayDir.y < 0.0) orderMask |= 2u;
    if (rayDir.z < 0.0) orderMask |= 4u;

    // Push Root
    uint stackPtr = 1u;
    sNode[0] = chunk.nodeOffset;
    sMin[0] = chunk.worldMin;
    sSize[0] = chunk.worldMax.x - chunk.worldMin.x;
    sDepth[0] = 0u;
    sNextChild[0] = 0u;

    uint iter = 0u;
    while (stackPtr > 0u && iter++ < MAX_ITER) {
        uint si = stackPtr - 1u;

        // All children processed?
        if (sNextChild[si] >= 8u) {
            stackPtr--;
            continue;
        }

        uint idx = sNode[si];
        vec3 nodeMin = sMin[si];
        float size = sSize[si];
        uint depth = sDepth[si];

        SvoNode node = nodes[idx];

        if (node.childMask == 0u) {
            stackPtr--;
            continue;
        }

        float halfSize = size * 0.5;

        // Find next valid child
        bool foundChild = false;
        uint childNodeIndex;
        vec3 childMin;

        while (sNextChild[si] < 8u) {
            uint c = sNextChild[si];
            sNextChild[si] = c + 1u;

            uint octant = c ^ orderMask;

            if ((node.childMask & (1u << octant)) == 0u) continue;

            childMin = nodeMin + vec3(
                (octant & 1u) != 0u ? halfSize : 0.0,
                (octant & 2u) != 0u ? halfSize : 0.0,
                (octant & 4u) != 0u ? halfSize : 0.0
            );
            vec3 childMax = childMin + vec3(halfSize);

            vec2 t = intersectAABB(rayOrg, invDir, childMin, childMax);
            if (t.x > t.y || t.y < 0.0 || t.x > gl_RayTmaxEXT) continue;

            childNodeIndex = chunk.nodeOffset + node.firstChild + octant;
            if (childNodeIndex >= chunk.nodeOffset + chunk.nodeCount) continue;

            foundChild = true;
            break;
        }

        if (!foundChild) {
            stackPtr--;
            continue;
        }

        // Check if at leaf depth
        if (depth + 1u >= MAX_DEPTH) {
            SvoNode leaf = nodes[childNodeIndex];

            if (leaf.occupancy > 0.0) {
                vec3 childMax = childMin + vec3(halfSize);
                vec2 leafT = intersectAABB(rayOrg, invDir, childMin, childMax);
                float hitT = max(leafT.x, gl_RayTminEXT);

                if (hitT < gl_RayTmaxEXT) {
                    vec3 hitPos = rayOrg + rayDir * hitT;
                    uint faceID = getHitFace(hitPos, childMin, childMax);

                    hitAttribs.materialId = leaf.materialId;
                    reportIntersectionEXT(hitT, faceID);
                }
            }
            continue;
        }

        // Push child
        if (stackPtr < MAX_STACK) {
            sNode[stackPtr] = childNodeIndex;
            sMin[stackPtr] = childMin;
            sSize[stackPtr] = halfSize;
            sDepth[stackPtr] = depth + 1u;
            sNextChild[stackPtr] = 0u;
            stackPtr++;
        }
    }
}