/*
* File: intersect.rint
* Project: blok
* Author: Collin Longoria
* Created on: 12/1/2025
*/

#version 460
#extension GL_EXT_ray_tracing : require

struct SvoNode {
    uint childMask;
    uint firstChild;
    uint materialId;
    float occupancy;
};

struct SubChunkGpu {
    uint nodeOffset;      // Offset into global node array
    uint rootNodeIndex;   // Sub-chunk's root node (relative to nodeOffset)
    uint nodeCount;       // Total nodes in parent chunk
    uint startDepth;      // Depth at which sub-chunk starts

    vec3 worldMin;
    float subChunkSize;

    vec3 worldMax;
    float pad0;
};

layout(binding = 1, set = 0) readonly buffer SvoBuffer {
    SvoNode nodes[];
};

layout(binding = 2, set = 0) readonly buffer SubChunkBuffer {
    SubChunkGpu subChunks[];
};

struct HitAttribs {
    uint materialId;
};
hitAttributeEXT HitAttribs hitAttribs;

const uint MAX_STACK = 12u;
const uint MAX_ITER = 128u;
const uint MAX_DEPTH = 7u; // Total SVO depth
const uint SUB_CHUNK_DEPTH = 2u; // log2(SUB_CHUNK_DIVISIONS) - must match CPU!
const float INV_EPS = 1e-8;

vec2 intersectAABB(vec3 origin, vec3 invDir, vec3 boxMin, vec3 boxMax) {
    vec3 t0 = (boxMin - origin) * invDir;
    vec3 t1 = (boxMax - origin) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);

    return vec2(tNear, tFar);
}

uint getHitFace(vec3 hitPos, vec3 boxMin, vec3 boxMax) {
    vec3 center = (boxMin + boxMax) * 0.5;
    vec3 diff = hitPos - center;
    vec3 halfSize = (boxMax - boxMin) * 0.5;
    vec3 dist = abs(diff) - halfSize;

    if (dist.x > dist.y && dist.x > dist.z) return diff.x > 0 ? 0 : 1;
    if (dist.y > dist.z) return diff.y > 0 ? 2 : 3;
    return diff.z > 0 ? 4 : 5;
}

void main() {
    // Get sub-chunk data
    SubChunkGpu sub = subChunks[gl_PrimitiveID];

    vec3 rayOrg = gl_WorldRayOriginEXT;
    vec3 rayDir = gl_WorldRayDirectionEXT;

    vec3 invDir = vec3(
        abs(rayDir.x) > INV_EPS ? 1.0 / rayDir.x : sign(rayDir.x) * 1e30,
        abs(rayDir.y) > INV_EPS ? 1.0 / rayDir.y : sign(rayDir.y) * 1e30,
        abs(rayDir.z) > INV_EPS ? 1.0 / rayDir.z : sign(rayDir.z) * 1e30
    );

    // Test against sub-chunk AABB
    vec2 subT = intersectAABB(rayOrg, invDir, sub.worldMin, sub.worldMax);
    if (subT.x > subT.y || subT.y < 0.0 || subT.x > gl_RayTmaxEXT) return;

    // Stack for traversal
    uint sNode[MAX_STACK];
    vec3 sMin[MAX_STACK];
    float sSize[MAX_STACK];
    uint sDepth[MAX_STACK];
    uint sNextChild[MAX_STACK];

    // Ray direction ordering
    uint orderMask = 0u;
    if (rayDir.x < 0.0) orderMask |= 1u;
    if (rayDir.y < 0.0) orderMask |= 2u;
    if (rayDir.z < 0.0) orderMask |= 4u;

    // The sub-chunk root is at depth = startDepth in the original SVO
    uint stackPtr = 1u;
    sNode[0] = sub.nodeOffset + sub.rootNodeIndex;  // Absolute index into global nodes
    sMin[0] = sub.worldMin;                          // Sub-chunk bounds
    sSize[0] = sub.subChunkSize;                     // Sub-chunk size
    sDepth[0] = sub.startDepth;                      // Start at sub-chunk depth
    sNextChild[0] = 0u;

    uint iter = 0u;
    while (stackPtr > 0u && iter++ < MAX_ITER) {
        uint si = stackPtr - 1u;

        // All children processed?
        if (sNextChild[si] >= 8u) {
            stackPtr--;
            continue;
        }

        uint idx = sNode[si];
        vec3 nodeMin = sMin[si];
        float size = sSize[si];
        uint depth = sDepth[si];

        // Bounds check - use sub-chunk's parent chunk node count
        if (idx >= sub.nodeOffset + sub.nodeCount) {
            stackPtr--;
            continue;
        }

        SvoNode node = nodes[idx];

        if (node.childMask == 0u) {
            stackPtr--;
            continue;
        }

        float halfSize = size * 0.5;

        // Find next valid child
        bool foundChild = false;
        uint childNodeIndex;
        vec3 childMin;

        while (sNextChild[si] < 8u) {
            uint c = sNextChild[si];
            sNextChild[si] = c + 1u;

            uint octant = c ^ orderMask;

            if ((node.childMask & (1u << octant)) == 0u) continue;

            childMin = nodeMin + vec3(
                (octant & 1u) != 0u ? halfSize : 0.0,
                (octant & 2u) != 0u ? halfSize : 0.0,
                (octant & 4u) != 0u ? halfSize : 0.0
            );
            vec3 childMax = childMin + vec3(halfSize);

            vec2 t = intersectAABB(rayOrg, invDir, childMin, childMax);
            if (t.x > t.y || t.y < 0.0 || t.x > gl_RayTmaxEXT) continue;

            // Child index is relative to firstChild
            childNodeIndex = sub.nodeOffset + node.firstChild + octant;

            // Bounds check
            if (childNodeIndex >= sub.nodeOffset + sub.nodeCount) continue;

            foundChild = true;
            break;
        }

        if (!foundChild) {
            stackPtr--;
            continue;
        }

        // Check if at leaf depth
        if (depth + 1u >= MAX_DEPTH) {
            SvoNode leaf = nodes[childNodeIndex];

            if (leaf.occupancy > 0.0) {
                vec3 childMax = childMin + vec3(halfSize);
                vec2 leafT = intersectAABB(rayOrg, invDir, childMin, childMax);
                float hitT = max(leafT.x, gl_RayTminEXT);

                if (hitT < gl_RayTmaxEXT) {
                    vec3 hitPos = rayOrg + rayDir * hitT;
                    uint faceID = getHitFace(hitPos, childMin, childMax);

                    hitAttribs.materialId = leaf.materialId;
                    reportIntersectionEXT(hitT, faceID);
                }
            }
            continue;
        }

        // Push child onto stack
        if (stackPtr < MAX_STACK) {
            sNode[stackPtr] = childNodeIndex;
            sMin[stackPtr] = childMin;
            sSize[stackPtr] = halfSize;
            sDepth[stackPtr] = depth + 1u;
            sNextChild[stackPtr] = 0u;
            stackPtr++;
        }
    }
}
