/*
* File: atrous.comp
* Project: blok
* Author: Collin Longoria
* Created on: 12/5/2025
*/

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// CHANGED: Use image instead of sampler to avoid bilinear blur across voxel edges
layout(binding = 0) uniform sampler2D inColor;

layout(binding = 1, r32f)    uniform readonly image2D inVariance;
layout(binding = 2, rgba32f) uniform readonly image2D inWorldPosition;
layout(binding = 3, rgba16f) uniform readonly image2D inNormalRoughness;

layout(binding = 4, rgba32f) uniform writeonly image2D outColor;

layout(binding = 5) uniform FrameUBO {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;
    vec3 camPos;
    float deltaTime;
    vec3 prevCamPos;
    uint depth;
    uint frameCount;
    uint sampleCount;
    uint screenWidth;
    uint screenHeight;
    float temporalAlpha;
    float momentAlpha;
    float varianceClipGamma;
    float depthThreshold;
    float normalThreshold;
    float phiColor;
    float phiNormal;
    float phiDepth;
    int atrousIteration;
    int stepSize;
    float varianceBoost;
    int minHistoryLength;
} frame;

layout(push_constant) uniform PushConstants {
    int stepSize;
    float phiColor;
    float phiNormal;
    float phiDepth;
} pc;

// 5x5 à-trous kernel weights
const float kernel[3] = float[3](1.0, 2.0/3.0, 1.0/6.0);

const ivec2 offsets[25] = ivec2[25](
    ivec2(-2, -2), ivec2(-1, -2), ivec2(0, -2), ivec2(1, -2), ivec2(2, -2),
    ivec2(-2, -1), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1), ivec2(2, -1),
    ivec2(-2,  0), ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0), ivec2(2,  0),
    ivec2(-2,  1), ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1), ivec2(2,  1),
    ivec2(-2,  2), ivec2(-1,  2), ivec2(0,  2), ivec2(1,  2), ivec2(2,  2)
);

float luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

float computeKernelWeight(ivec2 offset) {
    int kx = abs(offset.x);
    int ky = abs(offset.y);
    if (kx > 2 || ky > 2) return 0.0;
    return kernel[kx] * kernel[ky];
}

// IMPROVED: Better variance-guided color weight
float computeColorWeight(vec3 centerColor, vec3 sampleColor, float variance) {
    vec3 diff = centerColor - sampleColor;
    float colorDistSq = dot(diff, diff);

    // Variance-guided sigma
    // Add base sigma to prevent over-filtering when variance is very low
    float baseSigma = 0.01;
    float varianceSigma = pc.phiColor * sqrt(max(variance, 0.0));
    float sigma = baseSigma + varianceSigma;

    return exp(-colorDistSq / (2.0 * sigma * sigma + 1e-6));
}

// IMPROVED: Sharper normal falloff for voxels
float computeNormalWeight(vec3 centerNormal, vec3 sampleNormal) {
    float dotProduct = max(dot(centerNormal, sampleNormal), 0.0);

    // For voxels with axis-aligned normals:
    // - Same face: dot = 1.0 -> weight = 1.0
    // - Adjacent face (90°): dot = 0.0 -> weight = 0.0
    // - Opposite face: dot = -1.0 -> weight = 0.0

    // Use a threshold instead of power for hard edges
    // Normals within ~25° get full weight, then sharp falloff
    float threshold = 0.9; // cos(25°) ≈ 0.906
    if (dotProduct < threshold) {
        return 0.0;
    }

    // Smooth falloff above threshold
    float t = (dotProduct - threshold) / (1.0 - threshold);
    return t * t; // Quadratic falloff in the valid range
}

// IMPROVED: Plane-aware depth weight for voxels
float computeDepthWeight(vec3 centerWorldPos, vec3 sampleWorldPos, vec3 centerNormal, float centerDepth, float sampleDepth) {
    // For voxels, we care about whether we're on the same surface

    // Method 1: Simple depth difference (good for axis-aligned views)
    float depthDiff = abs(centerDepth - sampleDepth);

    // Method 2: Plane distance (better for angled views)
    vec3 posDiff = sampleWorldPos - centerWorldPos;
    float planeDistance = abs(dot(posDiff, centerNormal));

    // Combine both - use whichever is more restrictive
    float effectiveDistance = max(depthDiff * 0.1, planeDistance);

    // Threshold based on step size (larger steps = more tolerance)
    float sigma = pc.phiDepth * float(pc.stepSize) + 0.1;

    // Hard cutoff for voxel edges
    if (effectiveDistance > sigma * 2.0) {
        return 0.0;
    }

    return exp(-effectiveDistance * effectiveDistance / (sigma * sigma + 1e-6));
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    if (coord.x >= int(frame.screenWidth) || coord.y >= int(frame.screenHeight)) {
        return;
    }

    // Load center pixel data - USE POINT SAMPLING for voxels
    vec2 centerUV = (vec2(coord) + 0.5) / vec2(frame.screenWidth, frame.screenHeight);
    vec3 centerColor = texture(inColor, centerUV).rgb;

    vec4 centerWorldPosData = imageLoad(inWorldPosition, coord);
    vec4 centerNormalData = imageLoad(inNormalRoughness, coord);
    float centerVariance = imageLoad(inVariance, coord).r;

    vec3 centerWorldPos = centerWorldPosData.xyz;
    float centerDepth = centerWorldPosData.w;
    vec3 centerNormal = normalize(centerNormalData.xyz);

    // Sky check
    if (centerDepth > 9000.0) {
        imageStore(outColor, coord, vec4(centerColor, 1.0));
        return;
    }

    // Accumulate filtered color
    vec3 sumColor = vec3(0.0);
    float sumWeight = 0.0;

    for (int i = 0; i < 25; i++) {
        ivec2 offset = offsets[i] * pc.stepSize;
        ivec2 sampleCoord = coord + offset;
        sampleCoord = clamp(sampleCoord, ivec2(0), ivec2(frame.screenWidth - 1, frame.screenHeight - 1));

        // POINT SAMPLE - no bilinear interpolation across voxel edges
        vec2 sampleUV = (vec2(sampleCoord) + 0.5) / vec2(frame.screenWidth, frame.screenHeight);
        vec3 sampleColor = texture(inColor, sampleUV).rgb;

        vec4 sampleWorldPosData = imageLoad(inWorldPosition, sampleCoord);
        vec4 sampleNormalData = imageLoad(inNormalRoughness, sampleCoord);

        vec3 sampleWorldPos = sampleWorldPosData.xyz;
        float sampleDepth = sampleWorldPosData.w;
        vec3 sampleNormal = normalize(sampleNormalData.xyz);

        // Skip sky
        if (sampleDepth > 9000.0) {
            continue;
        }

        // Compute weights
        float kernelWeight = computeKernelWeight(offsets[i]);
        float colorWeight = computeColorWeight(centerColor, sampleColor, centerVariance);
        float normalWeight = computeNormalWeight(centerNormal, sampleNormal);
        float depthWeight = computeDepthWeight(centerWorldPos, sampleWorldPos, centerNormal, centerDepth, sampleDepth);

        float weight = kernelWeight * colorWeight * normalWeight * depthWeight;

        // Minimum weight threshold to avoid near-zero contributions
        if (weight < 0.001) {
            continue;
        }

        sumColor += sampleColor * weight;
        sumWeight += weight;
    }

    vec3 outputColor;
    if (sumWeight > 0.01) {
        outputColor = sumColor / sumWeight;
    } else {
        outputColor = centerColor;
    }

    outputColor = max(outputColor, vec3(0.0));
    imageStore(outColor, coord, vec4(outputColor, 1.0));
}