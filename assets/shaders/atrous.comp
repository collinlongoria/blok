/*
* File: atrous.comp
* Project: blok
* Author: Collin Longoria
* Created on: 12/5/2025
*/

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D inColor;

layout(binding = 1, r32f)    uniform readonly image2D inVariance;
layout(binding = 2, rgba32f) uniform readonly image2D inWorldPosition;
layout(binding = 3, rgba16f) uniform readonly image2D inNormalRoughness;

layout(binding = 4, rgba32f) uniform writeonly image2D outColor;

layout(binding = 5) uniform FrameUBO {
    // Current frame
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;

    // Previous frame
    mat4 prevView;
    mat4 prevProj;
    mat4 prevViewProj;

    vec3 camPos;
    float deltaTime;

    vec3 prevCamPos;
    uint depth;

    uint frameCount;
    uint sampleCount;
    uint screenWidth;
    uint screenHeight;

    float temporalAlpha;
    float momentAlpha;
    float varianceClipGamma;
    float depthThreshold;

    float normalThreshold;
    float phiColor;
    float phiNormal;
    float phiDepth;

    int atrousIteration;
    int stepSize;
    float varianceBoost;
    int minHistoryLength;
} frame;

layout(push_constant) uniform PushConstants {
    int stepSize;
    float phiColor;
    float phiNormal;
    float phiDepth;
} pc;

// 5x5 Gaussian kernel weights (separable, but we use 2D for simplicity)
// These are the Ã -trous B3-spline weights
const float kernel[3] = float[3](1.0, 2.0/3.0, 1.0/6.0);

// Full 5x5 kernel offsets (relative to center)
const ivec2 offsets[25] = ivec2[25](
    ivec2(-2, -2), ivec2(-1, -2), ivec2(0, -2), ivec2(1, -2), ivec2(2, -2),
    ivec2(-2, -1), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1), ivec2(2, -1),
    ivec2(-2,  0), ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0), ivec2(2,  0),
    ivec2(-2,  1), ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1), ivec2(2,  1),
    ivec2(-2,  2), ivec2(-1,  2), ivec2(0,  2), ivec2(1,  2), ivec2(2,  2)
);

float luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// Compute Gaussian spatial weight from kernel
float computeKernelWeight(ivec2 offset) {
    // Convert to kernel indices
    int kx = abs(offset.x);
    int ky = abs(offset.y);

    if (kx > 2 || ky > 2) return 0.0;

    // h[i] * h[j] for separable kernel
    return kernel[kx] * kernel[ky];
}

// Edge-stopping function for color (variance-guided)
float computeColorWeight(vec3 centerColor, vec3 sampleColor, float variance) {
    // Luminance difference
    float lumCenter = luminance(centerColor);
    float lumSample = luminance(sampleColor);
    float lumDiff = abs(lumCenter - lumSample);

    // Variance-guided sigma: higher variance = more permissive
    // This is the key insight from SVGF
    float sigma = pc.phiColor * sqrt(max(variance, 1e-10));

    // Gaussian weight
    return exp(-lumDiff * lumDiff / max(sigma * sigma, 1e-10));
}

// Edge-stopping function for normals
float computeNormalWeight(vec3 centerNormal, vec3 sampleNormal) {
    float dotProduct = max(dot(centerNormal, sampleNormal), 0.0);

    // Power function for sharper falloff
    return pow(dotProduct, pc.phiNormal);
}

// Edge-stopping function for depth/position
float computeDepthWeight(float centerDepth, float sampleDepth, vec3 centerNormal, ivec2 offset) {
    // Plane-based depth comparison
    // Project the offset onto the normal to get expected depth change
    float depthDiff = abs(centerDepth - sampleDepth);

    // Scale by step size (larger steps = more tolerance)
    float sigma = pc.phiDepth * float(pc.stepSize);

    return exp(-depthDiff * depthDiff / max(sigma * sigma, 1e-10));
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Bounds check
    if (coord.x >= int(frame.screenWidth) || coord.y >= int(frame.screenHeight)) {
        return;
    }

    // Load center pixel data
    vec2 centerUV = (vec2(coord) + 0.5) / vec2(frame.screenWidth, frame.screenHeight);
    vec3 centerColor = texture(inColor, centerUV).rgb;

    vec4 centerWorldPosData = imageLoad(inWorldPosition, coord);
    vec4 centerNormalData = imageLoad(inNormalRoughness, coord);
    float centerVariance = imageLoad(inVariance, coord).r;

    vec3 centerWorldPos = centerWorldPosData.xyz;
    float centerDepth = centerWorldPosData.w;
    vec3 centerNormal = normalize(centerNormalData.xyz);

    // Check for sky pixels (very large depth)
    if (centerDepth > 9000.0) {
        // Sky - no filtering needed
        imageStore(outColor, coord, vec4(centerColor, 1.0));
        return;
    }

    // Accumulate filtered color
    vec3 sumColor = vec3(0.0);
    float sumWeight = 0.0;

    // Apply 5x5 kernel with step size
    for (int i = 0; i < 25; i++) {
        ivec2 offset = offsets[i] * pc.stepSize;
        ivec2 sampleCoord = coord + offset;

        // Clamp to screen bounds
        sampleCoord = clamp(sampleCoord, ivec2(0), ivec2(frame.screenWidth - 1, frame.screenHeight - 1));

        // Sample color with bilinear filtering
        vec2 sampleUV = (vec2(sampleCoord) + 0.5) / vec2(frame.screenWidth, frame.screenHeight);
        vec3 sampleColor = texture(inColor, sampleUV).rgb;

        // Load sample geometry
        vec4 sampleWorldPosData = imageLoad(inWorldPosition, sampleCoord);
        vec4 sampleNormalData = imageLoad(inNormalRoughness, sampleCoord);

        vec3 sampleWorldPos = sampleWorldPosData.xyz;
        float sampleDepth = sampleWorldPosData.w;
        vec3 sampleNormal = normalize(sampleNormalData.xyz);

        // Skip sky pixels in samples
        if (sampleDepth > 9000.0) {
            continue;
        }

        // Compute Edge-Stopping Weights

        // Spatial Gaussian weight
        float kernelWeight = computeKernelWeight(offsets[i]);

        // Color weight (variance-guided)
        float colorWeight = computeColorWeight(centerColor, sampleColor, centerVariance);

        // Normal weight
        float normalWeight = computeNormalWeight(centerNormal, sampleNormal);

        // Depth weight
        float depthWeight = computeDepthWeight(centerDepth, sampleDepth, centerNormal, offset);

        // Combined weight
        float weight = kernelWeight * colorWeight * normalWeight * depthWeight;

        // Accumulate
        sumColor += sampleColor * weight;
        sumWeight += weight;
    }

    // Normalize
    vec3 outputColor;
    if (sumWeight > 1e-10) {
        outputColor = sumColor / sumWeight;
    } else {
        // Fallback to center color if all weights are zero
        outputColor = centerColor;
    }

    // Clamp to valid range
    outputColor = max(outputColor, vec3(0.0));

    // Write output
    imageStore(outColor, coord, vec4(outputColor, 1.0));
}